# 1. Why do we use the Carry Flag? (jnc .rdrand_loop)  
Think of the CPU's hardware random number generator as a vending machine for random numbers.
You use the rdrand rax instruction like "Hey, give me a random number!".
Sometimes, the machine might be busy or momentarily out of "randomness" (this is called running out of entropy). 
It can't give you a number at that exact nanosecond.
The Carry Flag (CF) is how the machine tells you if your request was successful.  
  
If CF = 1 (Carry flag is "set"), it means "Success! I put a fresh random number in the rax register for you."  
If CF = 0 (Carry flag is "clear"), it means "Sorry, I couldn't get one for you right now. Please try again."  
  
The instruction `jnc` means "Jump if No Carry". So, `jnc .rdrand_loop` translates to: "If the Carry Flag is 0 (meaning we failed to get a number), then jump back to the label .rdrand_loop and try again."
We loop until the hardware confirms it has given us a valid number.  
  
# 2. What is a hardware random number? (rdrand rax)  
A hardware random number is generated by a special, dedicated circuit inside the CPU. This circuit monitors incredibly small and unpredictable physical processes, like the thermal noise created by the movement of electrons in the silicon.  
Because these physical events are naturally chaotic, the numbers they produce are considered "truly" random, not just "pseudo-random" like those from a mathematical formula.  
So, when rdrand rax runs, it gives you a raw 64-bit integer (a number between 0 and about 18 quintillion) that is as unpredictable as modern technology can make it. We then use math (the modulo operator) to shrink that huge number down into our desired range of 0-100.  
  
# 3. Local Labels  
In NASM assembly, a label that starts with a dot (.) is a local label.  
This means it's "private" to the main function (a global label) that it's inside. You can't jump to it from another function. This is incredibly useful because you can reuse common loop names like `.loop`, `.done`, or `.error` inside every single one of your functions without them getting mixed up.  
  
```
MyFirstFunction:          ; This is a Global Label
    mov ecx, 10
.loop:                    ; This is a Local Label (belongs to MyFirstFunction)
    ; ... do something
    loop .loop            ; Jumps to the .loop inside this function
    ret

MySecondFunction:         ; This is another Global Label
    mov ecx, 5
.loop:                    ; This is also a Local Label, but it's completely
                          ; separate from the one in MyFirstFunction.
    ; ... do something else
    loop .loop
    ret
```
  
# 4. Integer to ASCII conversion (Easier than you think!)  
Our code does this by repeatedly dividing by 10 and looking at the remainder. We do it backward because it's easier to get the last digit first.  
## Step 1: Get the last digit  
Math: 142 / 10 equals 14 with a remainder of 2.  
We have the number (integer) 2. We need the character '2'. So, we just take our number (integer) 2 and add the ASCII value of '0'. (48 in decimal)  
Result: 2 + 48 = 50. (ASCII value of character '2' is 50) We store '2' as the last digit of our string.  
Let's say `integer value + ASCII value of 0 = ASCII value of an integer`  
## Step 2: Get the next digit  
Math: We now take the 14 from the previous step. 14 / 10 equals 1 with a remainder of 4.  
Result: 4 + '0' = '4'. We store '4' just before the '2'.  
## Step 3: Get the first digit  
Math: We take the 1 from the previous step. 1 / 10 equals 0 with a remainder of 1.  
Result: 1 + '0' = '1'. We store '1' just before the '4'. 
  
Finish: The number we are dividing is now 0, so we stop.  
We have extracted the digits in reverse order (2, 4, 1).  
That's why the code starts at the end of the `output_buffer` and works its way backward, so that when it's done, the final string in memory is correctly ordered as '1', '4', '2'.  
  
# 5. What is `ret` ?  
In technical terms, the ret (return) instruction transfers control back to the caller of a function or procedure. It does this by popping the return address from the stack and placing it in the instruction pointer (EIP or RIP), effectively resuming execution at the instruction following the call. The stack pointer is then adjusted to reflect the popped address. The ret instruction is often used in conjunction with the call instruction, which pushes the current instruction pointer onto the stack before jumping to a new address.  
Seems complex? Then note this short defination  
`ret` reverses the effect of `call`, returning control to the point where the function or procedure was called.  
  
# 6. Carry Flag (CF)  
The carry flag (CF or C) is a single bit within the processor's status flags register, indicating whether an arithmetic operation has resulted in a carry or borrow. Specifically, it's set to 1 when an addition produces a carry out of the most significant bit (MSB), or when a subtraction requires a borrow into the MSB. Otherwise, it's set to 0.  
For example, carry in Addition:  
When adding two numbers, if the result's MSB is 1 because a carry occurred, the carry flag is set to 1. For example, `1111 + 0001 = 10000` (MSB is 1, carry is 1)  
  
# 7. What is seeding? (Worth noting)  
In Random Number Generation, like our code, A "seed" value is used as the starting point for a pseudo-random number generator, ensuring that different seeds produce different sequences of random numbers  

### Well, that's it for now. Happy coding and hope you learnt well! :) 

